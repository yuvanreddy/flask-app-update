name: Deploy Flask App to EKS (with ALB)

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Docker image tag to deploy (e.g., master-eae7f2)"
        required: true
        type: string

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1
  EKS_CLUSTER_NAME: flask-eks
  NAMESPACE: default

  # Workload names
  DEPLOYMENT: flask-app
  CONTAINER: flask
  SERVICE: flask-svc
  APP_SA: flask-app-sa

  # Cloudsmith (EDIT THESE 3 TO MATCH YOUR ORG/REPO/IMAGE)
  REG_SERVER: docker.cloudsmith.io
  CLOUDSMITH_REPO: flask-sample-app/flask-sample-app   # <-- your org/repo path
  IMAGE_NAME: flask-devops-demo                        # <-- your image name

  # Ingress/ALB (optional)
  INGRESS_NAME: flask-alb
  HEALTHCHECK_PATH: /health

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: "latest"

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name "${EKS_CLUSTER_NAME}" --region "${AWS_REGION}"

      - name: Ensure namespace
        run: |
          kubectl get ns "${NAMESPACE}" >/dev/null 2>&1 || kubectl create ns "${NAMESPACE}"

      - name: Create/Update Cloudsmith imagePullSecret
        run: |
          kubectl create secret docker-registry cloudsmith-regcred \
            --namespace "${NAMESPACE}" \
            --docker-server="${REG_SERVER}" \
            --docker-username="${{ secrets.CLOUDSMITH_USERNAME }}" \
            --docker-password="${{ secrets.CLOUDSMITH_API_KEY }}" \
            --docker-email="devnull@example.com" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Ensure ServiceAccount uses imagePullSecret
        run: |
          kubectl apply -f - <<EOF
          apiVersion: v1
          kind: ServiceAccount
          metadata:
            name: ${APP_SA}
            namespace: ${NAMESPACE}
          imagePullSecrets:
          - name: cloudsmith-regcred
          EOF

      - name: Build image reference (with validations)
        id: img
        run: |
          set -e
          IMAGE_TAG="${{ github.event.inputs.image_tag }}"
          test -n "${REG_SERVER}" || { echo "REG_SERVER is empty"; exit 1; }
          test -n "${CLOUDSMITH_REPO}" || { echo "CLOUDSMITH_REPO is empty"; exit 1; }
          test -n "${IMAGE_NAME}" || { echo "IMAGE_NAME is empty"; exit 1; }
          test -n "${IMAGE_TAG}" || { echo "image_tag input is empty"; exit 1; }

          FULL_IMAGE="${REG_SERVER}/${CLOUDSMITH_REPO}/${IMAGE_NAME}:${IMAGE_TAG}"

          # safety checks
          echo "${FULL_IMAGE}" | grep -Eq '^[^ ]+$' || { echo "Image contains spaces"; exit 1; }
          echo "${FULL_IMAGE}" | grep -q ':$' && { echo "Image ends with colon"; exit 1; }
          echo "FULL_IMAGE=${FULL_IMAGE}" >> $GITHUB_ENV
          echo "Deploying image: ${FULL_IMAGE}"
          {
            echo "### Deploying"
            echo "- Image: \`${FULL_IMAGE}\`"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Ensure Deployment exists (create if missing)
        run: |
          if ! kubectl -n "${NAMESPACE}" get deploy "${DEPLOYMENT}" >/dev/null 2>&1; then
            echo "Creating initial Deployment ${DEPLOYMENT}"
            kubectl apply -f - <<EOF
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: ${DEPLOYMENT}
              namespace: ${NAMESPACE}
              labels: { app: ${DEPLOYMENT} }
            spec:
              replicas: 2
              selector:
                matchLabels: { app: ${DEPLOYMENT} }
              template:
                metadata:
                  labels: { app: ${DEPLOYMENT} }
                  annotations:
                    deployedAt: "$(date +%s)"
                spec:
                  serviceAccountName: ${APP_SA}
                  containers:
                    - name: ${CONTAINER}
                      image: ${FULL_IMAGE}
                      imagePullPolicy: Always
                      ports:
                        - containerPort: 5000
                          name: http
                      readinessProbe:
                        httpGet: { path: /health, port: 5000 }
                        initialDelaySeconds: 10
                        periodSeconds: 5
                        timeoutSeconds: 3
                        failureThreshold: 6
                      livenessProbe:
                        httpGet: { path: /health, port: 5000 }
                        initialDelaySeconds: 20
                        periodSeconds: 10
                        timeoutSeconds: 5
                        failureThreshold: 3
                      resources:
                        requests: { cpu: 100m, memory: 128Mi }
                        limits:   { cpu: 200m, memory: 256Mi }
            EOF
          fi

      - name: Set image & annotate
        run: |
          kubectl -n "${NAMESPACE}" set image deploy/${DEPLOYMENT} ${CONTAINER}="${FULL_IMAGE}" --record
          kubectl -n "${NAMESPACE}" annotate deploy/${DEPLOYMENT} deployedAt="$(date +%s)" --overwrite
          # Ensure imagePullPolicy Always so we don't reuse cached digest
          kubectl -n "${NAMESPACE}" patch deploy ${DEPLOYMENT} --type='merge' -p '{"spec":{"template":{"spec":{"containers":[{"name":"'${CONTAINER}'","imagePullPolicy":"Always"}]}}}}'

      - name: Rollout & diagnostics
        run: |
          set -e
          if ! kubectl -n "${NAMESPACE}" rollout status deploy/${DEPLOYMENT} --timeout=300s; then
            echo "::group::Describe Deployment"
            kubectl -n "${NAMESPACE}" describe deploy/${DEPLOYMENT} || true
            echo "::endgroup::"
            echo "::group::Pods"
            kubectl -n "${NAMESPACE}" get pods -l app=${DEPLOYMENT} -o wide || true
            for p in $(kubectl -n "${NAMESPACE}" get pods -l app=${DEPLOYMENT} -o jsonpath='{.items[*].metadata.name}'); do
              echo "---- Describe $p ----"
              kubectl -n "${NAMESPACE}" describe pod "$p" || true
              echo "---- Logs $p ----"
              kubectl -n "${NAMESPACE}" logs "$p" --container=${CONTAINER} --tail=200 || true
            done
            exit 1
          fi

      - name: Show endpoints
        run: |
          echo "=== Pods ==="
          kubectl -n "${NAMESPACE}" get pods -l app=${DEPLOYMENT} -o wide || true
          echo
          echo "=== Service ==="
          kubectl -n "${NAMESPACE}" get svc ${SERVICE} -o wide || true
          echo
          echo "=== Ingress ==="
          kubectl -n "${NAMESPACE}" get ingress ${INGRESS_NAME} -o wide || true
