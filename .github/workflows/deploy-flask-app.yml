name: Deploy Flask App to EKS (with ALB)

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Docker image tag to deploy (e.g., master-eae7f2)"
        required: true
        type: string

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1
  EKS_CLUSTER_NAME: flask-eks
  NAMESPACE: default

  # Workload identifiers
  DEPLOYMENT: flask-app
  CONTAINER: flask
  SERVICE: flask-svc
  APP_SA: flask-app-sa

  # Cloudsmith config (update if org/repo changes)
  REG_SERVER: docker.cloudsmith.io
  CLOUDSMITH_REPO: flask-sample-app/flask-sample-app
  IMAGE_NAME: flask-devops-demo

  # Optional ALB ingress
  INGRESS_NAME: flask-alb
  HEALTHCHECK_PATH: /health

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: "latest"

      - name: Update kubeconfig for EKS
        run: |
          aws eks update-kubeconfig --name "${EKS_CLUSTER_NAME}" --region "${AWS_REGION}"

      - name: Ensure namespace exists
        run: |
          kubectl get ns "${NAMESPACE}" >/dev/null 2>&1 || kubectl create ns "${NAMESPACE}"

      - name: Create or update Cloudsmith imagePullSecret
        run: |
          kubectl create secret docker-registry cloudsmith-regcred \
            --namespace "${NAMESPACE}" \
            --docker-server="${REG_SERVER}" \
            --docker-username="${{ secrets.CLOUDSMITH_USERNAME }}" \
            --docker-password="${{ secrets.CLOUDSMITH_API_KEY }}" \
            --docker-email="devnull@example.com" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Ensure workload ServiceAccount uses imagePullSecret
        run: |
          kubectl apply -f - <<'EOF'
          apiVersion: v1
          kind: ServiceAccount
          metadata:
            name: flask-app-sa
            namespace: default
          imagePullSecrets:
            - name: cloudsmith-regcred
          EOF

      - name: Build full image reference
        id: img
        run: |
          set -e
          IMAGE_TAG="${{ github.event.inputs.image_tag }}"
          test -n "${REG_SERVER}" || { echo "❌ REG_SERVER empty"; exit 1; }
          test -n "${CLOUDSMITH_REPO}" || { echo "❌ CLOUDSMITH_REPO empty"; exit 1; }
          test -n "${IMAGE_NAME}" || { echo "❌ IMAGE_NAME empty"; exit 1; }
          test -n "${IMAGE_TAG}" || { echo "❌ image_tag input empty"; exit 1; }

          FULL_IMAGE="${REG_SERVER}/${CLOUDSMITH_REPO}/${IMAGE_NAME}:${IMAGE_TAG}"
          echo "FULL_IMAGE=${FULL_IMAGE}" >> $GITHUB_ENV
          echo "Deploying ${FULL_IMAGE}"

      - name: Create Deployment (if not exists)
        shell: bash
        run: |
          if ! kubectl -n "${NAMESPACE}" get deploy "${DEPLOYMENT}" >/dev/null 2>&1; then
            echo "Creating initial deployment ${DEPLOYMENT}"
            kubectl create deployment "${DEPLOYMENT}" \
              --image="${FULL_IMAGE}" -n "${NAMESPACE}"
            kubectl -n "${NAMESPACE}" scale deployment "${DEPLOYMENT}" --replicas=2
            kubectl -n "${NAMESPACE}" expose deployment "${DEPLOYMENT}" --name="${SERVICE}" \
              --port=80 --target-port=5000 --type=ClusterIP
          fi

      - name: Update image and force rollout
        run: |
          kubectl -n "${NAMESPACE}" set image deploy/${DEPLOYMENT} ${CONTAINER}="${FULL_IMAGE}" --record
          kubectl -n "${NAMESPACE}" annotate deploy/${DEPLOYMENT} deployedAt="$(date +%s)" --overwrite
          kubectl -n "${NAMESPACE}" patch deploy ${DEPLOYMENT} --type='merge' -p \
            '{"spec":{"template":{"spec":{"containers":[{"name":"'${CONTAINER}'","imagePullPolicy":"Always"}]}}}}'

      - name: Wait for rollout and show diagnostics if fail
        run: |
          set -e
          if ! kubectl -n "${NAMESPACE}" rollout status deploy/${DEPLOYMENT} --timeout=300s; then
            echo "::group::Describe Deployment"
            kubectl -n "${NAMESPACE}" describe deploy/${DEPLOYMENT} || true
            echo "::endgroup::"
            echo "::group::Pods"
            kubectl -n "${NAMESPACE}" get pods -l app=${DEPLOYMENT} -o wide || true
            for p in $(kubectl -n "${NAMESPACE}" get pods -l app=${DEPLOYMENT} -o jsonpath='{.items[*].metadata.name}'); do
              echo "---- Describe $p ----"
              kubectl -n "${NAMESPACE}" describe pod "$p" || true
              echo "---- Logs $p ----"
              kubectl -n "${NAMESPACE}" logs "$p" --container=${CONTAINER} --tail=50 || true
            done
            exit 1
          fi

      - name: Show Service & Ingress
        run: |
          kubectl -n "${NAMESPACE}" get svc ${SERVICE} -o wide || true
          kubectl -n "${NAMESPACE}" get ingress ${INGRESS_NAME} -o wide || true
