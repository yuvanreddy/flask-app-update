name: Deploy Flask App to EKS

on:
  workflow_dispatch:
    inputs:
      image_ref:
        description: "Full image reference (e.g., docker.cloudsmith.io/flask-sample-app/flask-sample-app/flask-devops-demo:master-eae7f2)"
        required: true
        type: string

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1
  EKS_CLUSTER_NAME: flask-eks
  NAMESPACE: default

  DEPLOYMENT: flask-app
  CONTAINER: flask
  SERVICE: flask-svc
  APP_SA: flask-app-sa

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: latest

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name "${EKS_CLUSTER_NAME}" --region "${AWS_REGION}"

      - name: Validate input and print target image
        id: validate
        run: |
          set -e
          IMAGE_REF="${{ github.event.inputs.image_ref }}"
          echo "$IMAGE_REF" | grep -Eq '^[^ ]+$' || { echo "❌ image_ref empty/has spaces"; exit 1; }
          echo "$IMAGE_REF" | grep -q ':$' && { echo "❌ image_ref ends with colon"; exit 1; }
          echo "IMAGE_REF=$IMAGE_REF" >> $GITHUB_ENV
          echo "Deploying: $IMAGE_REF"

      - name: Ensure namespace + basic resources (idempotent)
        run: |
          kubectl get ns "${NAMESPACE}" >/dev/null 2>&1 || kubectl create ns "${NAMESPACE}"
          # ServiceAccount (for imagePullSecret, optional)
          kubectl apply -f - <<'EOF'
apiVersion: v1
kind: ServiceAccount
metadata:
  name: flask-app-sa
  namespace: default
EOF
          # Create Deployment minimally if missing (uses a placeholder image, replaced below)
          if ! kubectl -n "${NAMESPACE}" get deploy "${DEPLOYMENT}" >/dev/null 2>&1; then
            kubectl create deployment "${DEPLOYMENT}" -n "${NAMESPACE}" --image=nginx:stable
            kubectl -n "${NAMESPACE}" scale deployment "${DEPLOYMENT}" --replicas=2
            kubectl -n "${NAMESPACE}" expose deployment "${DEPLOYMENT}" --name="${SERVICE}" \
              --port=80 --target-port=5000 --type=ClusterIP
            # set container name to ${CONTAINER} if kubectl created "nginx"
            kubectl -n "${NAMESPACE}" patch deploy "${DEPLOYMENT}" --type='json' -p='[
              {"op":"replace","path":"/spec/template/spec/containers/0/name","value":"'"${CONTAINER}"'"},
              {"op":"add","path":"/spec/template/spec/containers/0/ports","value":[{"containerPort":5000,"name":"http"}]}
            ]'
          fi

      - name: Set image and imagePullPolicy atomically
        run: |
          # Set the image (keeps history)
          kubectl -n "${NAMESPACE}" set image deploy/${DEPLOYMENT} ${CONTAINER}="${IMAGE_REF}"
          # Ensure imagePullPolicy=Always without dropping the image field
          kubectl -n "${NAMESPACE}" patch deploy ${DEPLOYMENT} --type='merge' -p "{
            \"spec\": { \"template\": { \"spec\": { \"containers\": [
              { \"name\": \"${CONTAINER}\", \"image\": \"${IMAGE_REF}\", \"imagePullPolicy\": \"Always\" }
            ]}}}
          }"

      - name: Wait for rollout (with diagnostics on failure)
        run: |
          set -e
          if ! kubectl -n "${NAMESPACE}" rollout status deploy/${DEPLOYMENT} --timeout=300s; then
            echo "::group::Describe Deployment"
            kubectl -n "${NAMESPACE}" describe deploy/${DEPLOYMENT} || true
            echo "::endgroup::"
            echo "::group::Pods"
            kubectl -n "${NAMESPACE}" get pods -l app=${DEPLOYMENT} -o wide || true
            for p in $(kubectl -n "${NAMESPACE}" get pods -l app=${DEPLOYMENT} -o jsonpath='{.items[*].metadata.name}'); do
              echo "---- Describe $p ----"
              kubectl -n "${NAMESPACE}" describe pod "$p" || true
              echo "---- Logs $p ----"
              kubectl -n "${NAMESPACE}" logs "$p" --container=${CONTAINER} --tail=120 || true
            done
            exit 1
          fi
