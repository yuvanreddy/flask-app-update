name: Build, Push & Deploy Flask App

on:
  push:
    branches: [ main, master, develop ]
    paths:
      - 'app.py'
      - 'requirements.txt'
      - 'Dockerfile'
      - 'k8s/**'
      - '.github/workflows/**'
      - '**.py'
  pull_request:
    branches: [ main, master, develop ]
    paths:
      - 'app.py'
      - 'requirements.txt'
      - 'Dockerfile'
      - '**.py'
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even without code changes'
        required: false
        default: "false"

permissions:
  contents: read
  security-events: write
  actions: read
  id-token: write

env:
  AWS_REGION: us-east-1
  EKS_CLUSTER_NAME: flask-eks
  NAMESPACE: default
  IMAGE_NAME: flask-devops-demo
  PYTHON_VERSION: '3.11'

  # Workload names
  DEPLOYMENT: flask-app
  CONTAINER: flask
  SERVICE: flask-svc

  # Cloudsmith (registry)
  REG_SERVER: docker.cloudsmith.io
  REG_SECRET: cloudsmith-regcred
  APP_SA: flask-app-sa
  CLOUDSMITH_REPO: flask-sample-app/flask-sample-app

  # Ingress/ALB settings
  INGRESS_NAME: flask-alb
  INGRESS_CLASS: alb
  INGRESS_GROUP: flask-demo
  HEALTHCHECK_PATH: /health
  BACKEND_PORT: 5000

jobs:
  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    outputs:
      security-passed: ${{ steps.security-check.outputs.passed }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install bandit[toml] safety

      - name: Run Bandit (SAST - Python Security)
        run: |
          echo "Running Bandit security scan..."
          bandit -r . -ll -f json -o bandit-report.json || true
          bandit -r . -ll -f screen
        continue-on-error: true

      - name: Run Safety (Dependency Vulnerability Scan)
        run: |
          echo "Scanning dependencies for known vulnerabilities..."
          safety scan --json > safety-report.json || true
          safety scan
        continue-on-error: true

      - name: Upload Security Reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-reports
          path: |
            bandit-report.json
            safety-report.json

      - name: Check Security Scan Results
        id: security-check
        run: |
          # Check if bandit found high severity issues
          if [ -f bandit-report.json ]; then
            HIGH_ISSUES=$(cat bandit-report.json | jq '.metrics.total.ISSUE_HIGH // 0')
            if [ "$HIGH_ISSUES" -gt 0 ]; then
              echo "High severity security issues found: $HIGH_ISSUES"
              echo "passed=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi
          echo "Security scan passed"
          echo "passed=true" >> $GITHUB_OUTPUT

  build-and-push:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: security-scan
    if: needs.security-scan.outputs.security-passed == 'true' || github.event.inputs.force_deploy == 'true'
    outputs:
      image-tag: ${{ steps.meta.outputs.version }}
      image-full: ${{ steps.image-info.outputs.full-image }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to CloudSmith
        uses: docker/login-action@v3
        with:
          registry: docker.cloudsmith.io
          username: ${{ secrets.CLOUDSMITH_USERNAME }}
          password: ${{ secrets.CLOUDSMITH_API_KEY }}

      - name: Extract metadata (tags, labels)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: docker.cloudsmith.io/${{ secrets.CLOUDSMITH_REPO }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix=latest-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: false
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Run Trivy (Table Format)
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: docker.cloudsmith.io/${{ secrets.CLOUDSMITH_REPO }}/${{ env.IMAGE_NAME }}:latest
          format: 'table'
          severity: 'CRITICAL,HIGH,MEDIUM'

      - name: Push to CloudSmith
        uses: docker/build-push-action@v5
        if: github.event_name != 'pull_request'
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Set image info
        id: image-info
        run: |
          IMAGE_TAG="latest-${{ github.sha }}"
          FULL_IMAGE="docker.cloudsmith.io/${{ secrets.CLOUDSMITH_REPO }}/${{ env.IMAGE_NAME }}:${IMAGE_TAG}"
          echo "full-image=${FULL_IMAGE}" >> $GITHUB_OUTPUT
          echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "Built and pushed: ${FULL_IMAGE}"

  deploy:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: [security-scan, build-and-push]
    if: |
      (needs.security-scan.outputs.security-passed == 'true' || github.event.inputs.force_deploy == 'true') &&
      (needs.build-and-push.result == 'success' || github.event.inputs.force_deploy == 'true') &&
      github.event_name != 'pull_request'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      - name: Update kubeconfig for EKS
        run: |
          aws eks update-kubeconfig --name "${EKS_CLUSTER_NAME}" --region "${AWS_REGION}"

      - name: Ensure namespace exists
        run: |
          kubectl get ns "${NAMESPACE}" >/dev/null 2>&1 || kubectl create ns "${NAMESPACE}"

      # --- Cloudsmith image pull secret + SA ---
      - name: Create/Update Cloudsmith imagePullSecret
        run: |
          kubectl create secret docker-registry "${REG_SECRET}" \
            --namespace "${NAMESPACE}" \
            --docker-server="${REG_SERVER}" \
            --docker-username="${{ secrets.CLOUDSMITH_USERNAME }}" \
            --docker-password="${{ secrets.CLOUDSMITH_API_KEY }}" \
            --docker-email="devnull@example.com" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Ensure workload ServiceAccount uses imagePullSecret
        run: |
          kubectl apply -f - <<EOF
          apiVersion: v1
          kind: ServiceAccount
          metadata:
            name: ${APP_SA}
            namespace: ${NAMESPACE}
          imagePullSecrets:
          - name: ${REG_SECRET}
          EOF

      # --- Ensure Service exists ---
      - name: Ensure Service exists
        run: |
          if ! kubectl -n "${NAMESPACE}" get svc "${SERVICE}" >/dev/null 2>&1; then
            kubectl apply -f - <<EOF
          apiVersion: v1
          kind: Service
          metadata:
            name: ${SERVICE}
            namespace: ${NAMESPACE}
            labels:
              app: ${DEPLOYMENT}
          spec:
            selector:
              app: ${DEPLOYMENT}
            ports:
            - name: http
              port: 80
              targetPort: ${BACKEND_PORT}
            type: ClusterIP
          EOF
          fi

      # --- Deploy with latest image ---
      - name: Deploy application
        run: |
          # Use the image from build-and-push job or fallback to latest
          IMAGE_TAG="${{ needs.build-and-push.outputs.image-tag || 'latest' }}"
          FULL_IMAGE="docker.cloudsmith.io/${CLOUDSMITH_REPO}/${IMAGE_NAME}:${IMAGE_TAG}"

          echo "Deploying image: ${FULL_IMAGE}"

          # Check if deployment exists, if not create it
          if ! kubectl -n "${NAMESPACE}" get deploy "${DEPLOYMENT}" >/dev/null 2>&1; then
            echo "Deployment ${DEPLOYMENT} not found, creating it..."
            kubectl apply -f k8s/deployment.yaml
            sleep 10  # Wait for deployment to be ready
          fi

          # Update deployment with new image
          kubectl set image deployment/${DEPLOYMENT} ${CONTAINER}=${FULL_IMAGE} -n ${NAMESPACE}

          # Add annotation to force rolling update
          kubectl patch deployment ${DEPLOYMENT} -n ${NAMESPACE} -p \
            "{\"spec\":{\"template\":{\"metadata\":{\"annotations\":{\"deployedAt\":\"$(date +'%s')\"}}}}" >/dev/null 2>&1 || true

      # --- Ensure ALB Ingress exists ---
      - name: Ensure Ingress exists
        run: |
          if ! kubectl -n "${NAMESPACE}" get ingress "${INGRESS_NAME}" >/dev/null 2>&1; then
            kubectl apply -f - <<EOF
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: ${INGRESS_NAME}
            namespace: ${NAMESPACE}
            annotations:
              alb.ingress.kubernetes.io/scheme: internet-facing
              alb.ingress.kubernetes.io/target-type: ip
              alb.ingress.kubernetes.io/group.name: ${INGRESS_GROUP}
              alb.ingress.kubernetes.io/healthcheck-path: ${HEALTHCHECK_PATH}
              alb.ingress.kubernetes.io/listen-ports: '[{"HTTP":80}]'
          spec:
            ingressClassName: ${INGRESS_CLASS}
            rules:
            - http:
                paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: ${SERVICE}
                      port:
                        number: 80
          EOF
          fi

      # --- Wait for ALB hostname and print endpoints ---
      - name: Fetch ALB address and Display URLs
        id: alb
        run: |
          echo "⏳ Waiting for ALB to be ready..."
          for i in $(seq 1 60); do
            HOST=$(kubectl -n "${NAMESPACE}" get ingress "${INGRESS_NAME}" -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || true)
            if [ -n "$HOST" ]; then
              echo "✅ ALB Ready! Hostname: $HOST"
              echo "host=$HOST" >> $GITHUB_OUTPUT

              echo ""
              echo "🎉 APPLICATION URLs:"
              echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
              echo "📱 Main App:      http://$HOST/"
              echo "🏥 Health Check:   http://$HOST${HEALTHCHECK_PATH}"
              echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
              echo ""

              # Also write to step summary for GitHub UI
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "🎉 **Application URLs:**" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**Main App:** http://$HOST/" >> $GITHUB_STEP_SUMMARY
              echo "**Health Check:** http://$HOST${HEALTHCHECK_PATH}" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "✅ **Deployment completed successfully!**" >> $GITHUB_STEP_SUMMARY
              break
            fi
            echo "Waiting... (attempt $i/60)"
            sleep 10
          done

          if [ -z "$HOST" ]; then
            echo "⚠️ ALB not ready after 10 minutes"
            echo "host=pending" >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "⏳ **ALB is still provisioning...**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Current Status:**" >> $GITHUB_STEP_SUMMARY
            kubectl get ingress ${INGRESS_NAME} -n ${NAMESPACE} -o wide >> $GITHUB_STEP_SUMMARY 2>/dev/null || echo "Unable to get status" >> $GITHUB_STEP_SUMMARY
          fi

  summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [security-scan, build-and-push, deploy]
    if: always()

    steps:
      - name: Generate Summary
        run: |
          echo "## 🚀 Build, Push & Deploy Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.security-scan.result }}" == "success" ]; then
            echo "✅ **Security Scan**: Passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ **Security Scan**: Failed" >> $GITHUB_STEP_SUMMARY
          fi

          if [ "${{ needs.build-and-push.result }}" == "success" ]; then
            echo "✅ **Docker Build**: Completed" >> $GITHUB_STEP_SUMMARY
            echo "✅ **Image Scan**: Completed" >> $GITHUB_STEP_SUMMARY
            echo "✅ **CloudSmith Push**: Completed" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ **Build & Push**: Failed" >> $GITHUB_STEP_SUMMARY
          fi

          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "✅ **Kubernetes Deployment**: Completed" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ **Kubernetes Deployment**: Failed" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Image**: docker.cloudsmith.io/${{ secrets.CLOUDSMITH_REPO }}/${{ env.IMAGE_NAME }}" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.build-and-push.outputs.image-tag }}" != "" ]; then
            echo "**Tag**: ${{ needs.build-and-push.outputs.image-tag }}" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "🎯 **Triggered by**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.event.head_commit.message }}" != "" ]; then
            echo "**Commit**: ${{ github.event.head_commit.message }}" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Note**: Application URLs are displayed in the deploy job above ↑" >> $GITHUB_STEP_SUMMARY
